// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// User (Wallet-based)
// NOTE: We only store public data - no private keys or API credentials
// All sensitive operations happen client-side or on Polymarket directly
model User {
  id            String   @id @default(cuid())
  walletAddress String   @unique
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Subscription
  tier          Tier     @default(FREE)
  stripeId      String?  @unique

  // Funder address (proxy wallet where funds are held - for proxy wallets only)
  // This is a PUBLIC address, not sensitive - just used to look up rewards
  funderAddress String?

  // Relations
  positions     Position[]
  payouts       Payout[]
  alerts        Alert[]
  goals         Goal[]

  @@index([walletAddress])
  @@index([tier])
}

enum Tier {
  FREE
  PREMIUM
  PRO
}

// Market
model Market {
  id            String   @id // Polymarket Gamma API ID (numeric)
  conditionId   String?  @unique // Polymarket condition ID (hex) - for Data API
  clobTokenIds  String?  // JSON array of CLOB token IDs [YES, NO] for order book API
  question      String
  description   String?

  // Reward Config
  maxSpread     Float    // Max spread from midpoint (e.g., 0.03 = 3Â¢)
  minSize       Float    // Minimum shares to qualify
  rewardPool    Float    // Daily USD reward amount

  // Market State
  midpoint      Float    // Current market midpoint
  volume        Float    @default(0)
  liquidity     Float    @default(0)
  endDate       DateTime
  active        Boolean  @default(true)
  resolved      Boolean  @default(false)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  snapshots     MarketSnapshot[]
  positions     Position[]
  orders        Order[]

  @@index([active, rewardPool])
  @@index([active, rewardPool, endDate])  // Composite index for market queries
  @@index([active, endDate])              // For filtering active markets by date
  @@index([endDate])
  @@index([conditionId])
}

// Market Snapshot (Historical data)
model MarketSnapshot {
  id          String   @id @default(cuid())
  marketId    String
  market      Market   @relation(fields: [marketId], references: [id], onDelete: Cascade)

  timestamp   DateTime @default(now())
  midpoint    Float
  totalQMin   Float    // Sum of all LPs' Q_min
  lpCount     Int      // Number of active LPs
  rewardPool  Float    // Snapshot of reward pool at time

  @@index([marketId, timestamp])
  @@index([timestamp])
}

// User Position (Calculated Q-scores)
model Position {
  id            String   @id @default(cuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  marketId      String
  market        Market   @relation(fields: [marketId], references: [id], onDelete: Cascade)

  // Q-Scores
  qOne          Float
  qTwo          Float
  qMin          Float

  // Estimates
  estimatedDaily  Float
  userShare       Float    // Percentage (0-1)
  competitionQMin Float    // Total Q_min of other LPs

  // Metadata
  capitalDeployed Float
  orderCount      Int

  calculatedAt    DateTime @default(now())

  @@unique([userId, marketId])
  @@index([userId])
  @@index([userId, estimatedDaily])  // For sorting user positions by rewards
  @@index([marketId])
  @@index([calculatedAt])
}

// Order (User's open orders)
model Order {
  id          String   @id @default(cuid())
  userId      String
  marketId    String
  market      Market   @relation(fields: [marketId], references: [id], onDelete: Cascade)

  // Order Details
  price       Float    // 0.0 to 1.0
  size        Float    // Number of shares
  side        Side     // YES or NO
  type        OrderType // BID or ASK

  // Metadata
  spread      Float    // Distance from midpoint
  score       Float    // Individual order score

  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId, marketId, active])
  @@index([userId, active])  // For fetching all user's active orders
  @@index([marketId, active])
}

enum Side {
  YES
  NO
}

enum OrderType {
  BID
  ASK
}

// Payout (On-chain reward distributions)
model Payout {
  id            String   @id @default(cuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  amount        Float
  date          DateTime
  txHash        String   @unique
  blockNumber   Int

  verified      Boolean  @default(false)
  createdAt     DateTime @default(now())

  @@index([userId, date])
  @@index([date])
  @@index([txHash])
}

// Alert
model Alert {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  type        AlertType
  marketId    String?
  threshold   Float?
  active      Boolean  @default(true)

  createdAt   DateTime @default(now())

  @@index([userId, active])
}

enum AlertType {
  COMPETITION      // Competition increased
  WHALE           // Large LP entered
  OPPORTUNITY     // New high-reward market
  PAYOUT          // Daily payout received
}

// API Cache (Optional - for rate limiting)
model ApiCache {
  id          String   @id @default(cuid())
  key         String   @unique
  data        Json
  expiresAt   DateTime
  createdAt   DateTime @default(now())

  @@index([key])
  @@index([expiresAt])
}

// Bot Configuration
model BotConfig {
  id                  String   @id @default(cuid())
  userId              String   @unique

  // Status
  enabled             Boolean  @default(false)

  // Capital Management
  maxCapitalPerMarket Float    @default(1000) // Max $ per market
  totalCapitalLimit   Float    @default(10000) // Total $ across all markets
  reserveCapital      Float    @default(1000) // Keep this much in reserve

  // Risk Parameters
  minQScore           Float    @default(0.5) // Minimum Q-score to consider
  minRewardPool       Float    @default(50) // Minimum daily reward pool ($)
  maxMarketsActive    Int      @default(10) // Max concurrent markets

  // Strategy
  autoScanInterval    Int      @default(3600) // Scan every N seconds (default 1h)
  requireApproval     Boolean  @default(true) // Require manual approval before execution

  // Advanced
  diversificationMode Boolean  @default(true) // Spread capital across markets
  rebalanceEnabled    Boolean  @default(false) // Auto-rebalance positions

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([userId])
}

// Bot Recommendation (Opportunities found by bot)
model BotRecommendation {
  id                String   @id @default(cuid())
  userId            String
  marketId          String

  // Opportunity Details
  qScore            Float
  estimatedDaily    Float
  capitalRequired   Float
  rewardPool        Float

  // Recommended Actions
  recommendedOrders Json     // Array of { price, size, side, type }
  reasoning         String   // Why this is a good opportunity
  priority          Priority @default(MEDIUM)

  // Status
  status            RecommendationStatus @default(PENDING)
  approvedAt        DateTime?
  executedAt        DateTime?
  rejectedAt        DateTime?

  // Results (if executed)
  executionResult   Json?    // Details of what happened
  ordersPlaced      Int      @default(0)

  createdAt         DateTime @default(now())
  expiresAt         DateTime // Recommendations expire after N hours

  @@index([userId, status])
  @@index([status, expiresAt])
  @@index([createdAt])
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum RecommendationStatus {
  PENDING         // Waiting for user approval
  APPROVED        // User approved, waiting execution
  EXECUTING       // Currently being executed
  EXECUTED        // Successfully executed
  REJECTED        // User rejected
  EXPIRED         // Recommendation expired
  FAILED          // Execution failed
}

// User Goals & Milestones
model Goal {
  id            String   @id @default(cuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Goal Details
  type          GoalType
  targetAmount  Float    // Target $ amount
  currentAmount Float    @default(0) // Current progress (cached)

  // Time Period
  period        GoalPeriod
  startDate     DateTime @default(now())
  endDate       DateTime

  // Status
  status        GoalStatus @default(ACTIVE)
  completedAt   DateTime?
  celebratedAt  DateTime?  // When user saw the celebration

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([userId, status])
  @@index([userId, endDate])
  @@index([status, endDate])
}

enum GoalType {
  EARNINGS     // Total earnings target
  STREAK       // Consecutive days target
  RANK         // Reach a certain rank
}

enum GoalPeriod {
  WEEKLY
  MONTHLY
  QUARTERLY
  YEARLY
  CUSTOM
}

enum GoalStatus {
  ACTIVE
  COMPLETED
  FAILED       // Didn't reach goal by end date
  CANCELLED
}

// Bot Execution Log
model BotExecutionLog {
  id                  String   @id @default(cuid())
  userId              String
  recommendationId    String?

  action              String   // "scan", "execute", "rebalance", etc.
  status              String   // "success", "error", "partial"

  // Details
  marketsScanned      Int      @default(0)
  opportunitiesFound  Int      @default(0)
  ordersPlaced        Int      @default(0)
  capitalDeployed     Float    @default(0)

  errorMessage        String?
  executionTime       Int      // milliseconds

  createdAt           DateTime @default(now())

  @@index([userId, createdAt])
  @@index([action])
}
